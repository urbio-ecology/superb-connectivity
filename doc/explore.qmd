---
title: "Brief Exploration of results"
author: "Nicholas Tierney"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: html
---

```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(echo = TRUE)
## target knits qmds in their own session, so load libraries here.
source(here::here("packages.R"))
tar_source()  # not always necessary
```

```{r}
#| label: load-targets
#| include: false
withr::with_dir(here::here(), {
tar_load(habitat)
tar_load(barrier)
tar_load(habitat_raster)
tar_load(barrier_raster)
tar_load(terra_areas_connected)
tar_load(results_connect_habitat)
tar_load(fragmentation_raster)
tar_load(buffered_habitat)
tar_load(remaining_habitat)
tar_load(patch_id_raster)
})
```

## Exploration

```{r}
# terra::as.polygons(patch_id_raster[[1]])
# plot(patch_id_raster[[1]])
```

```{r}
col2hex <- function(color_name) {
  rgb(t(col2rgb(color_name)), maxColorValue = 255)
}

col2hex("forestgreen")
```

## Habitat, Buffered Habitat, and Barrier

```{r}
#| echo: false
library(terra)
library(tidyterra)
library(colorspace)
library(ggtext)

# First, reclassify your rasters to assign actual color values
barrier_coloured <- subst(barrier_raster, 1, "white")
buffer_coloured <- subst(buffered_habitat, 1, lighten("forestgreen", 0.5))
habitat_coloured <- subst(habitat_raster, 1, "forestgreen")

# Now plot them in layers (bottom to top)
ggplot() +
  geom_spatraster(data = buffer_coloured) +
  geom_spatraster(data = barrier_coloured) +
  geom_spatraster(data = habitat_coloured) +
  scale_fill_identity(na.value = NA) +
  theme_minimal() +
 labs(title = "Distribution of <span style='color:#228B22'>habitat</span>, 
                <span style='color:#73CD73'>buffered habitat</span>, 
                and <span style='color:white'>barriers</span>") +
  theme_minimal(
    paper = "black"
  ) +
  theme(plot.title = element_markdown())  # This enables the HTML rendering
```

## Patch ID

```{r}
my_colours <- colorspace::qualitative_hcl(n = 7)

raster_patches <- as.factor(patch_id_raster[[1]])

unique_vals <- unique(values(raster_patches))
unique_vals <- unique_vals[!is.na(unique_vals)]

# assign colours cyclically
colour_indices <- ((unique_vals - 1) %% 7) + 1
colour_map <- my_colours[colour_indices]
names(colour_map) <- as.character(unique_vals)

ggplot() +
  geom_spatraster(data = raster_patches) +
  scale_fill_manual(values = colour_map, na.value = NA) +
  theme_minimal() +
  theme(legend.position = "none")
```


Explore results

```{r}
#| label: display-areas
terra_areas_connected |> 
  mutate(across(starts_with("area"), \(x) round(x, 3))) |> 
  datatable()
```

```{r}
#| label: display-connectivity
terra_areas_connected |> 
  mutate(across(where(is.numeric), \(x) round(x, 6))) |> 
  pivot_longer(
    cols = everything(),
    names_to = "Variable",
    values_to = "Value"
  ) |> 
  datatable()
```

```{r}
results_connect_habitat |> datatable()
```


## Running time

It is useful to understand how long the pipeline takes, let's take a look at the timing of some key targets

```{r}
#| label: running-time
target_timings <- tar_meta() |> dplyr::select(name, bytes, seconds)

target_timings |> 
  drop_na() |> 
  arrange(desc(seconds)) |> 
  mutate(
    bytes_pretty = prettyunits::pretty_bytes(bytes),
    .after = bytes
  ) |> 
  rename(
    target_name = name,
    runtime_seconds = seconds
  ) |> 
  datatable()

# target_timings |> 
#   filter(
#     name %in% c(
#       "vect_areas_connected",
#       "terra_areas_connected"
#     )
#   )
```


## Reproducibility

<details><summary>Reproducibility receipt</summary>

```{r}
## datetime
Sys.time()

## repository
if(requireNamespace('git2r', quietly = TRUE)) {
  git2r::repository()
} else {
  c(
    system2("git", args = c("log", "--name-status", "-1"), stdout = TRUE),
    system2("git", args = c("remote", "-v"), stdout = TRUE)
  )
}

## session info
sessionInfo()
```

</details>
